# 入出力

## 標準入力・標準出力・標準エラー出力

「標準入力」・「標準出力」・「標準エラー出力」にはそれぞれ次のように番号が割り振られています。

|  意味     |  番号    |  デバイス | 
| -------- | -------- | ------- |
| 標準入力       |  0  | キーボード |
| 標準出力       |  1  | ディスプレイ |
| 標準エラー出力  |  2  | ディスプレイ |

```bash
echo "お金がない"
```
これは標準出力（画面）に出力される

## リダイレクト
役割：コマンドの実行結果を指定のファイルへ直接出力してくれる
標準出力を画面ではなく別のモノに向けるのがリダイレクトで、「>」という記号で表します。リダイレクト先は、通常はファイルですが、プリンタなどに送ることも可能です。  
そして、大なり記号 > は、実は 1> のように数字の"1"が省略されている。 同様にして2> も使える。  

```bash
echo "お金" > result.txt
#result.txtに「お金」が書き込まれる。
```
続けて、
```bash
echo "ほしい" > result.txt
# >はファイルに上書きされる
```

### リダイレクトで既存ファイルに追加したい場合
「> ファイル名」でリダイレクトすると、ファイルは常に新規作成されます。つまり、既存のファイルを指定した場合は、新しい内容でファイルが上書きされることになります。

既存のファイルに追加したい場合は「>> ファイル名」のように「>>」で指定します。指定したファイルが存在しない場合は新規作成となります。

例えば、「dmesg」は起動時のシステムのメッセージを再表示するコマンドですが、起動時のメッセージはかなりの量があり、1画面で一度に見ることはできません。  
そこで、「more」というコマンドを使って1画面ずつ停止しながらメッセージを表示するのであれば、パイプを使って「dmesg | more」のようにコマンドを実行します。  

```bash
dmesg | more
```

さらに、dmesgコマンドのメッセージを「systemlog.txt」という名前でファイルに保存したいのであれば、リダイレクトを使って「dmesg > systemlog.txt」のように実行します。
videoで絞り込んでsavelog.txtに保存（savelog.txtがあっても上書きされる）

```bash
dmesg | grep -i video > savelog.txt
```

consoleで絞り込んでsavelog.txtに追加保存（savelog.txtがない場合は新規作成）
```bash
dmesg | grep -i console >> savelog.txt
```
なお、grepコマンドの「-i」は大小文字の区別をしないという意味のオプションです。

> ※シェル変数「noclobber」がセットされていると、リダイレクト時のファイルの上書きを禁止することができます。
常に「noclobber」をセットしておくには、bashではホームディレクトリの「.bashrc」ファイルに「set -o noclobber」を設定。


ちなみに、標準入力をリダイレクトしたい場合は「<」という記号を使います。　　
例えば、「more < ファイル名」のように指定すると、リダイレクトで指定したファイルの内容が表示されます。　　
ただし、moreコマンドの場合は「more ファイル名」のように引数にファイルを指定することができるためリダイレクトする必要はありません。

```bash
command 2> error.txt
#commandを実行した際に表示されたエラーの内容が、error.txtに出力される
```

※Webで使われている「CGI（Common Gateway Interface）」でも、標準入出力が使われています。  
WebサーバはOS（シェル）を通じてCGIプログラムを実行し、CGIプログラムが標準出力に出力した内容を受け取り、Webクライアント（Webブラウザなど）に渡す、というのが大まかな仕組みになります。


### 第2の出力「標準エラー出力」とは？
多くのコマンドは“実行結果”を画面に表示しますが、この実行結果には **「コマンドが生成するデータ」** と **「エラーメッセージ」** の2種類があります。

例えば、「more ファイル名」ならばファイルの内容が1画面ずつ出力されますが、これが「コマンドが生成するデータ」です。  
また、指定したファイルが存在しない、アクセス権限がない、などのメッセージが「エラーメッセージ」です。

エラーメッセージの出力先を **「標準エラー出力」** と呼びます。通常は、標準出力も標準エラー出力も出力先は画面なので一見すると同じですが、出力としては区別されています。
※結果をどちら（標準出力か標準エラー出力）に出すかは、コマンドによって（コマンドを作成した人のポリシーによって）異なります。　　
通常のパイプ（|）やリダイレクト（>）は標準出力を対象としている。


### 標準出力と標準エラー出力を同じファイルへ
```bash
command > file.txt 2>&1
```
これは「file.txtに標準出力と標準エラー出力を書き込む」という意味です。
末尾にある2>&1より、標準エラー出力先は、現在の標準出力先、つまりfile.txtということです。

標準出力と標準エラー出力を同じファイルに書き込みたい場合は特別な記法があり
```bash
command &> file.txt
```
と実行すれば実現できます。

## コマンドを連結するパイプ（|）
役割：| の前にあるコマンドの出力を、| の後にあるコマンドの入力とする

```bash
echo "hello world"
#hello world
#（echoは入力したものをそのまま出力してくれるコマンド）
```

ここでは"hello world"と打って画面に標準出力しました。  
その結果をrevコマンドの標準入力として実行したのが次です：
```bash
echo "hello world" | rev
# dlrow olleh
# revは入力した文字列を逆さまにして返すコマンド）
```

つまり上の例では echoコマンドの出力を直接revコマンドに入力したということです。
ちなみに、パイプは複数個繋げることが出来ます。

### 「パイプ」と「リダイレクト」を使うとどんなことができるのか？

Linuxのコマンドラインを使いこなす上でポイントとなるのは、「パイプ（パイプライン）」と「リダイレクト」の活用です。




## パイプとリダイレクトの活用
ここからは「find」コマンドを例に、パイプとリダイレクトを組み合わせて標準出力と標準エラー出力を操作する方法を幾つか紹介します。

findコマンドはファイルを検索するコマンドで、 「find 検索場所 検索条件」のように指定して実行します。
```bash
find / -name '\*.log'
#ルートディレクトリ下、つまり全てのディレクトリ下にある、拡張子が「.log」のファイルが全て表示されます
```

検索条件として指定している「-name '*.log'」の「*」はどんな文字でも、何文字でもよい、という意味の指定です。  
findコマンドは、見つかったファイル名を標準出力に、ディレクトリにアクセス権がないので探せないような時のエラーメッセージは標準エラー出力に出力します。

検索場所にルートディレクトリ（/）を指定すると、全てのディレクトリが検索されますが、一般ユーザーではアクセスできないような場所も含まれることから、
実行結果（見つかったファイル）に混ざってエラーメッセージもたくさん表示されます

それでは、これをパイプやリダイレクトで操作してみましょう。

### 実行結果とエラーメッセージを別々に保存する

\> によるリダイレクトは、標準出力だけが対象となります。
```bash
#つまり
find / -name '*.log' > ファイル名
```
ではエラーメッセージは保存されません。

エラーメッセージ、つまり標準エラー出力への出力をリダイレクトしたい場合は「2>」で指定します。

bashでは内部で標準入力は「0」、標準出力は「1」、標準エラー出力は「2」の番号が割り振られています。  
従って、標準出力であることを明示したい場合は **「1>」** と指定します。

標準出力と標準エラー出力への出力を合わせて保存したい場合は、「&>」を使って「
```bash
find / -name '*.log' &> all.txt
```
のように指定します


### 全てのメッセージをmoreコマンドで表示する
　「find / -name \'\*.log' | more」のように、findコマンドの結果を単純にパイプでmoreコマンドに渡すと、標準出力だけがmoreに渡るため、エラーメッセージ（標準エラー出力）はそのまま流れていってしまいます。

　そこで
 ```bash
 find / -name '*.log' |& more
```
のようにすると、標準出力と標準エラー出力の内容を合わせて、つまり、findコマンドが出した全ての内容がmoreコマンドに渡るようになります。
- bashの「|&」は「2>&1 |」の短縮形です。「2>&1」で標準エラー出力を標準出力に接続した上でパイプに渡す、という意味です。

### エラーメッセージ（標準エラー出力）は表示しない
エラーメッセージは不要、という場合は「2> /dev/null」で標準エラーメッセージを「/dev/null」へリダイレクトします
「/dev/null」というのは「ヌルデバイス」という特別な場所で、ここへの出力は全て破棄され、どこにも出力されず、保存もされません。


### 検索結果（標準出力）だけをmoreコマンドで表示する
findコマンドで見つかった結果が多い場合は、標準エラー出力を「/dev/null」にリダイレクトした後にパイプでmoreコマンドに渡すことで、結果を1画面ずつ表示することができます。

今回のfindコマンドに限れば「find / -name '*.log' |& grep -v "許可"」のようにして、grepコマンドでエラーメッセージを取り除くという方法もあります。「grep -v 文字列」は指定した文字列が含まれていない行を表示するという意味で、「文字列」部分にはエラーメッセージにだけ使われるフレーズを指定しましょう。さらに、moreを付けたいならば「find / -name '*.log' |& grep -v "許可" | more」とします。なお、この方法はbashでも使えます。


### エラーメッセージ（標準エラー出力）だけをmoreコマンドで表示する
先ほどとは逆に、エラーメッセージだけをmoreコマンドで表示したい場合は、サブシェルを使い「(find / -name \'\*.log' > /dev/null) |& more」のようにします。これは、()の中でいったん標準出力の内容を/「dev/null」に捨てて、あらためて全ての出力をmoreに渡す、というようなことをしています（画面12）。

また、bashの場合は「find / -name \'\*.log' 2>&1 1>/dev/null | more」のようにすることもできます（画面13）。「2>&1」は2番つまり標準エラー出力を、1番つまり標準出力と同じ所へリダイレクトする、という意味です。

最後に、今回紹介したパイプとリダイレクト、標準出力と標準エラー出力を、以下の表1と表2にまとめました。意味や使い方が分からなくなった際には参考にしてください。

| | 標準出力 | 標準エラー出力 |	両方 |
| ----- | ----- | ----- | ----- |
| リダイレクト |	> または 1 > |	2> |	&> |
| リダイレクトへの追加 | >> または 1>>	| 2>> |	&>> |
| （使い方） |	command > file | command 2>file |	command &> file |
| パイプ	| \| | なし | \|& |
| (使い方) |	command \| command |（※1） |	command \|& command |

表1　パイプとリダイレクト（bash）
※1　標準エラー出力だけをパイプで別コマンドに渡したい場合はサブシェルを使い「( command > /dev/null ) | & command」のようにするか、「command 2>&1 1>/dev/null | command」のようにする（本文参照）


|    | 標準出力 | 標準エラー出力 |	両方 |
| ----- | ----- | ----- | ----- |
| リダイレクト |	>	| なし | >& |
| リダイレクトへの追加 | >> |    |	>>& |
|（使い方） | command > file |	(※2）| command >& file |
| パイプ | \|	| なし | & |
| (使い方） | command1\|command2 |	（※3）	| command1 \|& command2 |


表2　パイプとリダイレクト（tcsh）
※2　標準出力と標準エラー出力を別々のファイルに保存したい場合はサブシェルを使い「(command > file1) >& file2」のようにする（本文参照）
※3　標準エラー出力をだけパイプで別コマンドに渡したい場合はサブシェルを使い「( command > /dev/null ) | & command」のようにする


## 数値を比較する(比較演算子）

| 演算子 | 書き方 | 意味 | 例  |
|-----|------|-------|------|
| eq  | x -eq y | x = y | \[ 5 -eq 5 \] && echo "True"→ True |
| ge  | x -ge y | x >= y | \[ 5-ge 3 \] && echo "True" → True |
| gt  | x -gt y | x > y | \[ 5-gt 3 \] && echo "True" → True |
| le  | x -le y | x <= Y | \[ 3-le 5 \] && echo "True" → True |
| It  | x -lt y | x < y | \[ 3-It 5 \] && echo "True" → True |
| ne  | x -ne y | x != y | \[ 1 -ne 2 ]\ && echo "True" → True |

```bash
#!/bin/bash

count=10

if [ $count -gt 5 ]; then
    echo "countは5より大きい"
else
    echo "countは5以下"
fi
```


$(( )) 内部の数式を数値として評価  
書き方は計算したい式を、 $(( と ))で囲みます。  
比較結果として、真の場合は 1、偽の場合は 0 が返されます。  

| 演算子 |  例  |  結 果  |
| ------ | ------| -----|
| >   | echo $(( 2 > 3 )) | 0 |
| ==  | echo $(( 2 == 3)) | 0 |
| !=  | echo $(( 2 != 3 )) | 1 |
| <   | echo $(( 2 < 3 ))  | 1 |


